# Assessment v2.1: Filename Collision Resolution for Option 2

## Critical Issue Identified

You're absolutely correct - the flat `attachments/` directory structure would cause **filename collisions**. Multiple DISPLAYABLE_DATA documents will have attachments named `image-1.jpeg`, `audio-1.mp3`, etc.

## Current Attachment Naming Analysis

From examining the codebase:

**Naming Pattern**: 
- Images: `image-1`, `image-2`, `image-3` (per document)
- Audio: `audio-1`, `audio-2`, `audio-3` (per document)
- Generated by `MediaDragDropUploader.vue` with sequential numbering

**Document Structure**:
```json
{
  "_id": "e92135c6c3ba6fba79367e7f260026dc",
  "_attachments": {
    "image-1": { "stub": true, "content_type": "image/jpeg" },
    "audio-1": { "stub": true, "content_type": "audio/mpeg" }
  }
}
```

**Collision Confirmation**: Multiple documents indeed have `image-1`, `audio-1`, etc.

## Revised Directory Structure Options

### Option A: Document ID Namespacing (Recommended)
```
static-courses/course-123/
├── chunks/
├── indices/  
├── attachments/
│   ├── e92135c6c3ba6fba79367e7f260026dc/
│   │   ├── image-1.jpeg
│   │   └── audio-1.mp3
│   ├── f03246d7d4cb7geb80478f8g370137ed/
│   │   ├── image-1.jpeg
│   │   └── image-2.png
│   └── ...
└── manifest.json
```

### Option B: Flattened with Document ID Prefix
```
static-courses/course-123/
├── chunks/
├── indices/
├── attachments/
│   ├── e92135c6c3ba6fba79367e7f260026dc_image-1.jpeg
│   ├── e92135c6c3ba6fba79367e7f260026dc_audio-1.mp3
│   ├── f03246d7d4cb7geb80478f8g370137ed_image-1.jpeg
│   └── ...
└── manifest.json
```

### Option C: Content-Type Grouping with ID Prefix
```
static-courses/course-123/
├── chunks/
├── indices/
├── attachments/
│   ├── images/
│   │   ├── e92135c6c3ba6fba79367e7f260026dc_image-1.jpeg
│   │   └── f03246d7d4cb7geb80478f8g370137ed_image-1.jpeg
│   ├── audio/
│   │   └── e92135c6c3ba6fba79367e7f260026dc_audio-1.mp3
│   └── documents/
└── manifest.json
```

## Impact on Implementation

### Document Reference Updates

**Current stub format**:
```json
"_attachments": {
  "image-1": {
    "stub": true,
    "content_type": "image/jpeg"
  }
}
```

**Option A - Directory namespacing**:
```json
"_attachments": {
  "image-1": {
    "path": "attachments/e92135c6c3ba6fba79367e7f260026dc/image-1.jpeg",
    "content_type": "image/jpeg"
  }
}
```

**Option B - Filename prefixing**:
```json
"_attachments": {
  "image-1": {
    "path": "attachments/e92135c6c3ba6fba79367e7f260026dc_image-1.jpeg", 
    "content_type": "image/jpeg"
  }
}
```

## Static Data Adapter Impact

### ✅ No Changes Required to Static DB Core
- The static database adapters work with the transformed JSON documents
- They don't need to know about the attachment file organization
- Path resolution happens in higher-level components

### ⚠️ Minor Updates Needed for URL Resolution

**New Static DB Method**:
```typescript
interface StaticCourseDB {
  // New method for attachment URL resolution
  getAttachmentUrl(docId: string, attachmentName: string): string;
  
  // Existing methods unchanged
  getDocument(id: string): Promise<any>;
  getAllDocuments(): Promise<any[]>;
}
```

**Implementation for Option A**:
```typescript
getAttachmentUrl(docId: string, attachmentName: string): string {
  // Path is already in the document's _attachments, just resolve relative to base
  const doc = await this.getDocument(docId);
  const attachment = doc._attachments?.[attachmentName];
  return attachment?.path ? new URL(attachment.path, this.baseUrl).href : '';
}
```

## Packer Implementation Changes

### Enhanced Attachment Extraction Process

```typescript
async function extractDocumentAttachments(
  doc: any, 
  couchdbUrl: string, 
  outputDir: string
): Promise<void> {
  if (!doc._attachments) return;
  
  // Create document-specific directory (Option A)
  const docAttachmentDir = path.join(outputDir, 'attachments', doc._id);
  await fs.mkdir(docAttachmentDir, { recursive: true });
  
  for (const [attachmentName, metadata] of Object.entries(doc._attachments)) {
    const response = await fetch(`${couchdbUrl}/${doc._id}/${attachmentName}`);
    const extension = getExtensionFromContentType(metadata.content_type);
    const filename = `${attachmentName}${extension}`;
    const filepath = path.join(docAttachmentDir, filename);
    
    // Save binary file
    const buffer = await response.arrayBuffer();
    await fs.writeFile(filepath, new Uint8Array(buffer));
    
    // Update document reference
    doc._attachments[attachmentName] = {
      ...metadata,
      path: `attachments/${doc._id}/${filename}`,
      stub: false
    };
  }
}
```

## Recommendation: Option A (Document ID Directories)

**Why Option A is best**:

1. **Clear organization**: Each document's attachments are logically grouped
2. **Intuitive structure**: Easy to understand and debug
3. **Scalable**: Works well with many attachments per document
4. **Efficient**: Directory listing shows all attachments for a document
5. **Future-proof**: Easy to add metadata files or additional document-scoped resources

**Implementation complexity**: **Low** - minimal changes to static adapters, straightforward packer updates

**Performance impact**: **Negligible** - modern filesystems handle directory structures efficiently

## Required Modifications Summary

### 1. Packer Changes (packages/cli & packages/db)
- Create document ID subdirectories in attachments/
- Update attachment stub transformation logic
- Add concurrent download handling with proper directory creation

### 2. Static DB Runtime Changes (packages/db/src/static)
- Add `getAttachmentUrl()` method to resolve attachment paths
- Update manifest to include attachment directory metadata (optional)

### 3. Frontend Changes (minimal)
- Ensure attachment URL resolution uses the new static DB method
- Verify existing components work with the new path structure

### 4. No Breaking Changes
- Existing static courses continue to work (just without attachments)
- All current APIs remain unchanged
- Backward compatibility maintained

**Timeline Impact**: Minimal - this is still the same fundamental approach with proper namespacing added.