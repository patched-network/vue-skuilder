# E2E Pipeline: Test Roadmap

This document tracks the interactions we want to script and assert against. Everything here uses **real components** - no mocks.

## Current State

We have one working E2E test (`tests/pipeline/hierarchy-filter-e2e.test.ts`) that:
- Creates real CouchDB databases
- Inserts cards and strategies via raw PouchDB
- Initializes real DataLayerProvider
- Calls real `courseDB.getWeightedCards()` through real Pipeline
- Verifies 2 cards returned with correct structure

## Goal: Headless Platform Drivers

These tests serve dual purpose:
1. **Regression testing** during development
2. **Prototype headless drivers** that may graduate to:
   - Platform-as-a-Service backends
   - AI tutoring services (education-focused bolt.new)

---

## Test Categories

### 1. Full Content Lifecycle via MCP

**Goal:** Script entire course creation through MCP tools, then verify pipeline behavior.

```
MCP create_card (multiple) → MCP create_strategy →
Initialize DataLayer → courseDB.getWeightedCards() → Assert order
```

#### Tests to Write

- [ ] **MCP card creation flows into pipeline**
  - Create 5 cards via TestMCPClient
  - Create ELO strategy via MCP
  - Verify getWeightedCards() returns them with proper scoring

- [ ] **MCP strategy creation respected by pipeline**
  - Create hierarchy strategy via MCP with levels: `[intro, core, advanced]`
  - Create cards tagged with each level
  - Verify new user only sees `intro` cards

- [ ] **MCP update_card affects pipeline output**
  - Create card with low ELO
  - Update ELO via MCP
  - Verify scoring changes

### 2. Session Behavior with User Profiles

**Goal:** Different users (varying mastery, ELO, history) get appropriate cards.

#### User Profile Scenarios

- [ ] **Brand new user** (no history)
  - Should see level-1 cards from hierarchy
  - Should see cards near default ELO (1200)
  - No review cards (nothing to review)

- [ ] **User with partial mastery**
  - Insert user history: 80% correct on `level-1` tag
  - Should unlock `level-2` cards
  - `level-1` cards should have lower priority

- [ ] **User with high ELO**
  - Set user ELO to 1800
  - Should prioritize cards with ELO near 1800
  - Low-ELO cards should score poorly

- [ ] **User with scheduled reviews**
  - Insert cards in user's review queue
  - Verify review cards appear with appropriate priority
  - Verify overdue reviews get boosted

### 3. Nav Strategy Constraint Verification

**Goal:** Assert that strategies actually constrain what gets shown.

#### Hierarchy Filter Tests

- [ ] **Strict level gating**
  - 3-level hierarchy with 0.9 unlock threshold
  - User has 85% on level-1 (below threshold)
  - Assert: NO level-2 cards appear

- [ ] **Level unlocking**
  - Same setup, user has 92% on level-1
  - Assert: level-2 cards now appear
  - Assert: level-3 still blocked

- [ ] **Multi-level unlock**
  - User has mastered levels 1 and 2
  - Assert: levels 1, 2, 3 all available
  - Assert: higher levels still respect mastery

#### ELO Distance Filter Tests

- [ ] **Cards outside ELO range excluded**
  - User ELO: 1200, filter range: 200
  - Cards at ELO 800 should be filtered out
  - Cards at ELO 1100-1300 should pass

- [ ] **ELO range adjusts to user**
  - Change user ELO from 1200 to 1600
  - Previously-valid cards (ELO 1100) now excluded
  - New cards (ELO 1500) now included

#### Strategy Combination Tests

- [ ] **ELO generator + hierarchy filter**
  - Cards generated by ELO proximity
  - Then filtered by hierarchy level
  - Verify both constraints respected

- [ ] **Multiple filters chain correctly**
  - ELO generator → hierarchy filter → interference filter
  - Verify final output respects all constraints

### 4. SessionController Queue Behavior

**Goal:** Real SessionController with real sources, verify queue management.

- [ ] **New cards flow through newQ**
  - Create session with real Pipeline source
  - Verify cards come from newQ initially
  - Verify dequeue counts increment

- [ ] **Failed cards enter failedQ**
  - Get card, mark as failed via `nextCard('marked-failed')`
  - Verify card is in failedQ
  - Verify it resurfaces based on probability

- [ ] **Failed card cleared on success**
  - Fail a card, then succeed on retry
  - Verify removed from failedQ
  - Verify not shown again immediately

- [ ] **Review cards populate reviewQ**
  - User has scheduled reviews in database
  - Verify reviewQ populated on session start
  - Verify review cards shown based on probability

- [ ] **Time pressure shifts priorities**
  - Session with 30 seconds remaining
  - Verify failedQ gets priority over newQ
  - Verify cleanup phase behavior

---

## Test Infrastructure Needed

### Real User Database Support

Currently we test against guest user. Need:
- [ ] Helper to create real user with specific ELO
- [ ] Helper to insert user card history
- [ ] Helper to insert scheduled reviews
- [ ] Cleanup helpers for user databases

### Session Testing Harness

- [ ] Helper to create real SessionController with real sources
- [ ] Helper to simulate card interactions (correct, incorrect)
- [ ] Helper to advance through session and collect metrics
- [ ] Debug info extraction for assertions

### Assertion Helpers

- [ ] `expectCardsFromLevel(cards, 'level-1')` - all cards have tag
- [ ] `expectNoCardsFromLevel(cards, 'level-2')` - no cards have tag
- [ ] `expectCardScoresDescending(cards)` - sorted by score
- [ ] `expectELORange(cards, min, max)` - all cards in ELO range

---

## Priority Order

1. **MCP → Pipeline flow** (validates authoring → consumption)
2. **User profile scenarios** (validates personalization)
3. **Strategy constraints** (validates business logic)
4. **SessionController queues** (validates study session)

---

## Non-Goals (for now)

- Browser/UI testing (use Cypress separately)
- Performance benchmarks (different concern)
- Multi-user concurrency (CouchDB handles this)
- Authentication/authorization (tested elsewhere)
